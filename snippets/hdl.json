{
    "File Header": {
        "prefix": "header",
        "body": [
            "// -----------------------------------------------------------------------------",
            "// Copyright (c) ${CURRENT_YEAR} ${1:YourCompany}. All rights reserved.",
            "// -----------------------------------------------------------------------------",
            "// File Name   : ${TM_FILENAME}",
            "// Author      : ${2:YourName}",
            "// Date        : ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}",
            "// Description : ${3:Module Description}",
            "// -----------------------------------------------------------------------------"
        ],
        "description": "Standard File Header"
    },
    "Module (Modern)": {
        "prefix": "module",
        "body": [
            "module ${1:module_name} #(",
            "    parameter int ${2:DATA_WIDTH} = 32",
            ") (",
            "    input  logic                      clk,",
            "    input  logic                      rst_n,",
            ");",
            "",
            "    $0",
            "",
            "endmodule : ${1:module_name}"
        ],
        "description": "SystemVerilog Module with Parameters"
    },
    "Module (Simple)": {
        "prefix": "module_simple",
        "body": [
            "module ${1:moduleName} (",
            "    input  ${2:clk},",
            "    input  ${3:rst_n},",
            ");",
            "    $0",
            "endmodule"
        ],
        "description": "Simple Verilog Module"
    },
    "Module Instantiation": {
        "prefix": ["inst", "instance"],
        "body": [
            "${1:module_type} #(",
            "    .${2:PARAM}(${3:val})",
            ") ${4:u_instance} (",
            "    .${5:port}(${6:sig})",
            ");"
        ],
        "description": "Module Instantiation Template"
    },
    "Package": {
        "prefix": "package",
        "body": [
            "package ${1:pkg_name};",
            "",
            "    $0",
            "",
            "endpackage : ${1:pkg_name}"
        ],
        "description": "SystemVerilog Package"
    },
    "Interface": {
        "prefix": "interface",
        "body": [
            "interface ${1:intf_name} (input logic clk, input logic rst_n);",
            "    ",
            "    $0",
            "    ",
            "endinterface : ${1:intf_name}"
        ],
        "description": "Interface Definition"
    },
    "Always FF (Sequential)": {
        "prefix": "always_ff",
        "body": [
            "always_ff @(posedge ${1:clk} or negedge ${2:rst_n}) begin : ${3:blk_name}",
            "    if (!${2:rst_n}) begin",
            "        $0",
            "    end else begin",
            "        $0",
            "    end",
            "end"
        ],
        "description": "Sequential Logic (DFF with Async Reset)"
    },
    "Always Comb (Combinational)": {
        "prefix": "always_comb",
        "body": [
            "always_comb begin : ${1:blk_name}",
            "    $0",
            "end"
        ],
        "description": "Combinational Logic Block"
    },
    "Always Latch": {
        "prefix": "always_latch",
        "body": [
            "always_latch begin : ${1:blk_name}",
            "    if (${2:enable}) begin",
            "        ",
            "    end",
            "end"
        ],
        "description": "Latch Logic Block"
    },
    "Always (Generic)": {
        "prefix": "always",
        "body": [
            "always @(${1:*}) begin",
            "    $0",
            "end"
        ],
        "description": "Standard Verilog Always Block"
    },
    "Always Posedge": {
        "prefix": "always_pos",
        "body": [
            "always @(posedge ${1:clk}) begin",
            "    $0",
            "end"
        ],
        "description": "Always Posedge Block"
    },
    "Initial Block": {
        "prefix": "initial",
        "body": [
            "initial begin",
            "    $0",
            "end"
        ],
        "description": "Initial Block"
    },
    "Begin Block": {
        "prefix": "begin",
        "body": [
            "begin",
            "    $0",
            "end"
        ],
        "description": "Begin Block"
    },
    "Generate Loop": {
        "prefix": "generate",
        "body": [
            "generate",
            "    for (genvar i = 0; i < ${1:N}; i++) begin : ${2:gen_blk}",
            "        $0",
            "    end",
            "endgenerate"
        ],
        "description": "Generate For Loop"
    },
    "Finite State Machine (FSM)": {
        "prefix": "fsm",
        "body": [
            "// --- FSM Definition ---",
            "typedef enum logic [${1:1}:0] {",
            "    ${2:IDLE},",
            "    ${3:ACTIVE}",
            "} state_t;",
            "state_t current_state, next_state;",
            "",
            "// 1. State Register",
            "always_ff @(posedge clk or negedge rst_n) begin",
            "    if (!rst_n) current_state <= ${2:IDLE};",
            "    else        current_state <= next_state;",
            "end",
            "",
            "// 2. Next State Logic",
            "always_comb begin",
            "    next_state = current_state;",
            "    case (current_state)",
            "        ${2:IDLE}: begin",
            "            if (${4:start}) next_state = ${3:ACTIVE};",
            "        end",
            "        ${3:ACTIVE}: begin",
            "            $0",
            "        end",
            "        default: next_state = ${2:IDLE};",
            "    endcase",
            "end"
        ],
        "description": "Standard 3-Segment FSM"
    },
    "If Statement": {
        "prefix": "if",
        "body": [
            "if (${1:condition}) begin",
            "    $0",
            "end"
        ],
        "description": "if block"
    },
    "If Else": {
        "prefix": "ifelse",
        "body": [
            "if (${1:condition}) begin",
            "    $2",
            "end else begin",
            "    $3",
            "end"
        ],
        "description": "if-else block"
    },
    "Case": {
        "prefix": "case",
        "body": [
            "case (${1:sel})",
            "    ${2:VAL_A}: $3;",
            "    default: $4;",
            "endcase"
        ],
        "description": "case statement"
    },
    "Unique Case (FSM)": {
        "prefix": "case_unique",
        "body": [
            "unique case (${1:current_state})",
            "    ${2:IDLE}: begin",
            "        $0",
            "    end",
            "    default: next_state = ${2:IDLE};",
            "endcase"
        ],
        "description": "Safe FSM Case with unique keyword"
    },
    "For Loop": {
        "prefix": "for",
        "body": [
            "for (int i = 0; i < ${1:limit}; i++) begin",
            "    $0",
            "end"
        ],
        "description": "For loop"
    },
    "While Loop": {
        "prefix": "while",
        "body": [
            "while (${1:condition}) begin",
            "    $0",
            "end"
        ]
    },
    "Posedge keywords": {
        "prefix": "posedge",
        "body": "posedge "
    },
    "Negedge keywords": {
        "prefix": "negedge",
        "body": "negedge "
    },
    "Logic": {
        "prefix": "logic",
        "body": "logic [${1:WIDTH}-1:0] ${2:name};"
    },
    "Wire": {
        "prefix": "wire",
        "body": "wire [${1:WIDTH}-1:0] ${2:name};"
    },
    "Reg": {
        "prefix": "reg",
        "body": "reg [${1:WIDTH}-1:0] ${2:name};"
    },
    "Bit": {
        "prefix": "bit",
        "body": "bit ${1:name};"
    },
    "Int": {
        "prefix": "int",
        "body": "int ${1:name};"
    },
    "Byte (Fixed)": {
        "prefix": "byte",
        "body": "byte ${1:byte_name} = ${2:8'h00};"
    },
    "Parameter": {
        "prefix": "parameter",
        "body": "parameter ${1:PARAM_NAME} = ${2:value};"
    },
    "Localparam": {
        "prefix": "localparam",
        "body": "localparam ${1:PARAM_NAME} = ${2:value};"
    },
    "Typedef Enum": {
        "prefix": "typedef enum",
        "body": [
            "typedef enum logic [${1:width}-1:0] {",
            "    $0,",
            "} ${2:enum_name_t};"
        ]
    },
    "Typedef Struct Packed": {
        "prefix": "struct packed",
        "body": [
            "typedef struct packed {",
            "    logic [${1:7}:0] ${2:field1};",
            "} ${4:struct_name_t};"
        ]
    },
    "Queue": {
        "prefix": "queue",
        "body": "${1:type} ${2:name}[$];"
    },
    "Dynamic Array": {
        "prefix": "darray",
        "body": "${1:type} ${2:name}[];"
    },
    "Associative Array": {
        "prefix": "assoc",
        "body": "${1:val_type} ${2:name}[${3:key_type}];"
    },
    "Include": {
        "prefix": "include",
        "body": "`include \"${1:file.v}\""
    },
    "Define": {
        "prefix": "define",
        "body": "`define ${1:MACRO} ${2:value}"
    },
    "Ifdef": {
        "prefix": "ifdef",
        "body": [
            "`ifdef ${1:MACRO}",
            "\t$0",
            "`endif"
        ]
    },
    "Ifndef": {
        "prefix": "ifndef",
        "body": [
            "`ifndef ${1:MACRO}",
            "\t$0",
            "`endif"
        ]
    },
    "Timescale": {
        "prefix": "timescale",
        "body": "`timescale ${1:1ns}/${2:1ps}"
    },
    "Default Nettype": {
        "prefix": "default_nettype",
        "body": "`default_nettype ${1:none}"
    },
    "Class": {
        "prefix": "class",
        "body": [
            "class ${1:ClassName};",
            "    function new();",
            "        $0",
            "    endfunction",
            "endclass : ${1:ClassName}"
        ],
        "description": "Generic Class"
    },
    "Class Extends": {
        "prefix": "class extends",
        "body": [
            "class ${1:ClassName} extends ${2:SuperClass};",
            "   function new();",
            "        super.new();",
            "        $0",
            "   endfunction",
            "endclass : ${1:ClassName}"
        ],
        "description": "Inherited Class"
    },
    "Task": {
        "prefix": "task",
        "body": [
            "task ${1:task_name}(${2:args});",
            "    $0",
            "endtask"
        ]
    },
    "Function": {
        "prefix": "function",
        "body": [
            "function ${1:void} ${2:func_name}(${3:args});",
            "    $0",
            "endfunction"
        ]
    },
    "SVA AXI Stability": {
        "prefix": "sva_axi_stable",
        "body": [
            "// SVA: Data must be stable when Valid is high and Ready is low",
            "property p_${1:bus}_stability;",
            "\t@(posedge clk) disable iff (!rst_n)",
            "\t(${2:valid} && !${3:ready}) |-> \\$stable(${4:data});",
            "endproperty",
            "",
            "assert_${1:bus}_stability: assert property(p_${1:bus}_stability)",
            "\telse `uvm_error(\"AXI_RULE\", \"${1:bus} Violation: Data changed during backpressure\");"
        ],
        "description": "AXI/Stream Stability Assertion"
    },
    "SVA Rose Check": {
        "prefix": "sva_rose",
        "body": [
            "assert property (@(posedge clk) disable iff (!rst_n) \\$rose(${1:sig}) |-> ${2:consequence});"
        ],
        "description": "Assertion for Signal Rising Edge"
    },
    "UVM Component": {
        "prefix": "uvm_comp",
        "body": [
            "class ${1:my_comp} extends ${2:uvm_component};",
            "\t`uvm_component_utils(${1:my_comp})",
            "",
            "\tfunction new(string name, uvm_component parent);",
            "\t\tsuper.new(name, parent);",
            "\tendfunction",
            "",
            "\tvirtual function void build_phase(uvm_phase phase);",
            "\t\tsuper.build_phase(phase);",
            "\t\t$0",
            "\tendfunction",
            "endclass : ${1:my_comp}"
        ]
    },
    "UVM Object": {
        "prefix": "uvm_obj",
        "body": [
            "class ${1:my_obj} extends ${2:uvm_object};",
            "\t`uvm_object_utils(${1:my_obj})",
            "",
            "\tfunction new(string name = \"${1:my_obj}\");",
            "\t\tsuper.new(name);",
            "\tendfunction",
            "endclass : ${1:my_obj}"
        ]
    },
    "UVM Objection": {
        "prefix": "uvm_objection",
        "body": [
            "phase.raise_objection(this);",
            "$0",
            "phase.drop_objection(this);"
        ],
        "description": "Raise and Drop Objections"
    },
    "UVM Analysis Port": {
        "prefix": "uvm_ap",
        "body": [
            "uvm_analysis_port #(${1:type_t}) ${2:ap_name};",
            "// In build_phase:",
            "${2:ap_name} = new(\"${2:ap_name}\", this);"
        ],
        "description": "UVM Analysis Port Definition"
    },
    "UVM Info": {
        "prefix": "uinfo",
        "body": "`uvm_info(\"${1:ID}\", \\$sformatf(\"${2:Msg: %d}\", ${3:val}), UVM_LOW)"
    },
    "UVM Error": {
        "prefix": "uerror",
        "body": "`uvm_error(\"${1:ID}\", \\$sformatf(\"${2:Error: %s}\", ${3:msg}))"
    },
    "UVM Fatal": {
        "prefix": "ufatal",
        "body": "`uvm_fatal(\"${1:ID}\", \"${2:Fatal Error!}\")"
    },
    "Assert Property": {
        "prefix": "assert property",
        "body": [
            "property ${1:p_name};",
            "    @(posedge clk) disable iff (!rst_n)",
            "        ${2:req} |-> ##${3:1} ${4:ack};",
            "endproperty",
            "",
            "assert_${1:p_name}: assert property(${1:p_name})",
            "    else `uvm_error(\"SVA\", \"Assertion ${1:p_name} Failed\");"
        ]
    },
    "Display": {
        "prefix": "display",
        "body": "\\$display(\"${1:Time: %0t} ${2:Msg}\", \\$time, ${3:args});"
    },
    "System CLOG2 (Log Base 2)": {
        "prefix": "clog2",
        "body": "\\$clog2(${1:VALUE})",
        "description": "Returns the ceiling of log2 (Essential for address width calculation)"
    },
    "System Bits (Width Calculation)": {
        "prefix": "bits",
        "body": "\\$bits(${1:signal_or_type})",
        "description": "Returns the number of bits in a signal or struct"
    },
    "System Onehot (Assertion)": {
        "prefix": "onehot",
        "body": "\\$onehot(${1:signal})",
        "description": "Returns true if exactly one bit is 1 (Crucial for Arbiter grants)"
    },
    "System Onehot0 (Assertion)": {
        "prefix": "onehot0",
        "body": "\\$onehot0(${1:signal})",
        "description": "Returns true if zero or one bit is 1"
    },
    "System Count Ones": {
        "prefix": "countones",
        "body": "\\$countones(${1:signal})",
        "description": "Returns the number of 1s (Used for Parity/Credit counters)"
    },
    "System Is Unknown (X Check)": {
        "prefix": "isunknown",
        "body": "\\$isunknown(${1:signal})",
        "description": "Returns true if any bit is X or Z (Use in SVA)"
    },
    "System Signed Cast": {
        "prefix": "signed",
        "body": "\\$signed(${1:signal})",
        "description": "Cast to signed for arithmetic"
    },
    "System Unsigned Cast": {
        "prefix": "unsigned",
        "body": "\\$unsigned(${1:signal})",
        "description": "Cast to unsigned"
    },
    "System String Format (UVM)": {
        "prefix": "sformatf",
        "body": "\\$sformatf(\"${1:Msg: %0d}\", ${2:val})",
        "description": "Returns a formatted string (Standard for UVM reporting)"
    },
    "System Cast (Dynamic)": {
        "prefix": "cast_dyn",
        "body": [
            "if (!\\$cast(${1:dest_obj}, ${2:src_obj})) begin",
            "    `uvm_error(\"CAST\", \"Dynamic cast failed from ${2} to ${1}\")",
            "end"
        ],
        "description": "Safe Dynamic Casting with Error Check"
    },
    "System Real Time": {
        "prefix": "realtime",
        "body": "\\$realtime",
        "description": "Returns current simulation time as real (float)"
    },
    "System Fatal": {
        "prefix": "fatal",
        "body": "\\$fatal(${1:1}, \"${2:Fatal Error Message}\");",
        "description": "Terminates simulation with exit code (For Critical Failures)"
    },
    "System Finish": {
        "prefix": "finish",
        "body": "\\$finish;",
        "description": "End simulation"
    },
    "Testbench Template": {
        "prefix": "tb_template",
        "body": [
            "`timescale 1ns/1ps",
            "",
            "module tb_${1:module_name};",
            "",
            "    // -------------------------------------------------------------------------",
            "    // 1. Parameters & Constants",
            "    // -------------------------------------------------------------------------",
            "    localparam CLK_PERIOD = 10.0; // Float for precision",
            "    localparam TIMEOUT    = 50000; // Cycles watchdog",
            "",
            "    // -------------------------------------------------------------------------",
            "    // 2. Signals & Interface",
            "    // -------------------------------------------------------------------------",
            "    logic clk;",
            "    logic rst_n;",
            "",
            "    // DUT Signals",
            "    // logic [31:0] ...",
            "",
            "    // -------------------------------------------------------------------------",
            "    // 3. DUT Instantiation",
            "    // -------------------------------------------------------------------------",
            "    ${1:module_name} #(",
            "        // .PARAM (VAL)",
            "    ) u_dut (",
            "        .clk   (clk),",
            "        .rst_n (rst_n)",
            "        // Connect other ports",
            "        $0",
            "    );",
            "",
            "    // -------------------------------------------------------------------------",
            "    // 4. Clock & Reset Generation",
            "    // -------------------------------------------------------------------------",
            "    initial begin",
            "        clk = 0;",
            "        forever #(CLK_PERIOD/2.0) clk = ~clk;",
            "    end",
            "",
            "    // Task: Standard Reset Sequence (Async assert, Sync deassert)",
            "    task apply_reset();",
            "    begin",
            "        \\$display(\"[%0t] Reset Asserted...\", \\$time);",
            "        rst_n = 0;",
            "        repeat(10) @(posedge clk);",
            "        @(negedge clk); // Release on negedge to avoid hold violations",
            "        rst_n = 1;",
            "        \\$display(\"[%0t] Reset Released...\", \\$time);",
            "    end",
            "    endtask",
            "",
            "    // -------------------------------------------------------------------------",
            "    // 5. Main Test Process",
            "    // -------------------------------------------------------------------------",
            "    initial begin",
            "        // 5.1 Waveform Dump",
            "        `ifdef DUMP_VCD",
            "            \\$dumpfile(\"tb_${1:module_name}.vcd\");",
            "            \\$dumpvars(0, tb_${1:module_name});",
            "        `endif",
            "        `ifdef DUMP_FSDB",
            "            \\$fsdbDumpfile(\"tb_${1:module_name}.fsdb\");",
            "            \\$fsdbDumpvars(0, tb_${1:module_name});",
            "        `endif",
            "",
            "        // 5.2 Test Sequence",
            "        apply_reset();",
            "",
            "        \\$display(\"[%0t] Test Started...\", \\$time);",
            "        // TODO: Driver Logic Here",
            "        repeat(100) @(posedge clk); // Placeholder",
            "",
            "        // 5.3 End of Simulation",
            "        \\$display(\"[%0t] TEST PASSED\", \\$time);",
            "        \\$finish;",
            "    end",
            "",
            "    // -------------------------------------------------------------------------",
            "    // 6. Watchdog (Safety Net)",
            "    // -------------------------------------------------------------------------",
            "    initial begin",
            "        repeat(TIMEOUT) @(posedge clk);",
            "        \\$display(\"\\nError: Simulation Timeout after %0d cycles!\", TIMEOUT);",
            "        \\$display(\"[%0t] TEST FAILED (TIMEOUT)\", \\$time);",
            "        \\$fatal;",
            "    end",
            "",
            "endmodule"
        ],
        "description": "Professional SV Testbench with Watchdog & Safe Reset"
    }
}